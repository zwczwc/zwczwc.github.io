<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/06/05/hello-world/"/>
    <url>/2021/06/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>自建VPS科学上网指南</title>
    <link href="/2020/10/13/%E8%87%AA%E5%BB%BAVPS%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%8C%87%E5%8D%97/"/>
    <url>/2020/10/13/%E8%87%AA%E5%BB%BAVPS%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>每次换服务器都重新上网搜一遍，现在还是稍微整理一下吧。</p><p>日常使用还是✈️场，线路更有保证。自建 VPS 仅作为紧急备用。</p><p>服务器购买略去，只用来上网的话一般最低配置就够用了，系统 ubuntu or debian</p><p>买完服务器后去控制台能看到 ssh 登录的地址和密码，用自带的网页终端或者 XShell 连都可以</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>个人使用直接233的一键脚本</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">bash &lt;(curl -s -L https:<span class="hljs-regexp">//gi</span>t.io/v2ray.sh)<br></code></pre></td></tr></table></figure><blockquote><p>如果提示 curl: command not found ，那是因为你的 VPS 没装 Curl<br>ubuntu/debian 系统安装 Curl 方法: <code>apt-get update -y &amp;&amp; apt-get install curl -y</code><br>centos 系统安装 Curl 方法: <code>yum update -y &amp;&amp; yum install curl -y</code><br>安装好 curl 之后就能安装脚本了</p></blockquote><p>然后一路回车默认配置就可以了</p><h3 id="管理分享"><a href="#管理分享" class="headerlink" title="管理分享"></a>管理分享</h3><p>终端窗口输入 v2ray 即可管理各种配置</p><p>常用指令</p><p><code>v2ray</code> 主菜单</p><p><code>v2ray url</code> 查看分享链接</p><p><code>v2ray qr</code> 查看分享二维码</p><p><code>v2ray start</code> 启动 V2Ray</p><p><code>v2ray stop</code> 停止 V2Ray</p><p><code>v2ray restart</code> 重启 V2Ray</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>可以启用BBR优化，如果是 ubuntu or debian，默认就自动启用了。不放心可以进主菜单的其他再检查启用一下。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>下载对应平台客户端，添加链接或者扫二维码使用</p><p><a href="https://github.com/2dust/v2rayN">Windows</a></p><p><a href="https://github.com/2dust/v2rayNG">Android</a></p><p>iOS自行转区购买小火箭或者Quantumult</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android平台下的播放器框架资料收藏</title>
    <link href="/2018/09/13/Android%E5%B9%B3%E5%8F%B0%E4%B8%8B%E7%9A%84%E6%92%AD%E6%94%BE%E5%99%A8%E6%A1%86%E6%9E%B6%E8%B5%84%E6%96%99%E6%94%B6%E8%97%8F/"/>
    <url>/2018/09/13/Android%E5%B9%B3%E5%8F%B0%E4%B8%8B%E7%9A%84%E6%92%AD%E6%94%BE%E5%99%A8%E6%A1%86%E6%9E%B6%E8%B5%84%E6%96%99%E6%94%B6%E8%97%8F/</url>
    
    <content type="html"><![CDATA[<p>实习时做短视频优化查到比较多关于Android平台下的播放器框架资料，先把链接贴上来，迟点再整理。（懒= =）</p><h2 id="Andorid视频播放"><a href="#Andorid视频播放" class="headerlink" title="Andorid视频播放"></a>Andorid视频播放</h2><p><a href="https://blog.csdn.net/pangpang123654/article/details/78125038">硬解码与软解码的选择</a></p><p><a href="https://blog.csdn.net/Guofengpu/article/details/51544454">MediaCodec介绍</a></p><p><a href="https://blog.csdn.net/hejjunlin/article/details/53729575">MediaCodec，讲得好</a></p><p><a href="http://www.cnblogs.com/roger-yu/p/5635494.html">MediaCodec中文文档</a></p><p><a href="http://sparkgis.com/2018/07/10/android-mediaplayer-%E5%92%8C-mediacodec-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%EF%BC%88%E4%B8%80%EF%BC%89/">Android MediaPlayer 和 MediaCodec 的区别和联系</a></p><h2 id="Exoplayer"><a href="#Exoplayer" class="headerlink" title="Exoplayer"></a>Exoplayer</h2><p><a href="https://github.com/google/ExoPlayer">官网</a></p><p><a href="https://google.github.io/ExoPlayer/">官方指南</a></p><p><a href="http://google.github.io/ExoPlayer/doc/reference/">官方类参考</a></p><h2 id="ExoPlayer播放器对比"><a href="#ExoPlayer播放器对比" class="headerlink" title="ExoPlayer播放器对比"></a>ExoPlayer播放器对比</h2><p><a href="https://academy.realm.io/posts/360andev-effie-barak-switching-exoplayer-better-video-android/">官方介绍</a></p><p><a href="https://juejin.im/post/5a9f5726f265da239f06e874">掘金的主流播放器对比</a></p><p><a href="https://blog.csdn.net/pangpang123654/article/details/78256361">ExoPlayer VS IjkPlayer</a></p><p><a href="https://www.jianshu.com/p/74dbee4e0148">android平台视频框架小调研</a></p><h2 id="Exoplayer使用"><a href="#Exoplayer使用" class="headerlink" title="Exoplayer使用"></a>Exoplayer使用</h2><p><a href="https://qiita.com/niusounds/items/cce4ff69f5911908259b#%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%ABexoplayer%E3%82%92%E8%BF%BD%E5%8A%A0%E3%81%99%E3%82%8B">岛国码农介绍</a></p><p><a href="https://codelabs.developers.google.com/codelabs/exoplayer-intro/#4">谷歌CodeLabs</a></p><h2 id="Exoplayer过程分析"><a href="#Exoplayer过程分析" class="headerlink" title="Exoplayer过程分析"></a>Exoplayer过程分析</h2><p><a href="http://yummylau.com/2018/06/01/%E5%A4%9A%E5%AA%92%E4%BD%93_2018-06-01_ExoPlayer%E7%B3%BB%E5%88%97%E4%B8%80%E4%B9%8B%E5%A4%9A%E5%AA%92%E4%BD%93%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD/">多媒体加载</a></p><p><a href="http://yummylau.com/2018/06/02/%E5%A4%9A%E5%AA%92%E4%BD%93_2018-06-02_ExoPlayer%E7%B3%BB%E5%88%97%E4%BA%8C%E4%B9%8B%E5%B8%A6%E5%AE%BD%E9%A2%84%E6%B5%8B/">带宽预测</a></p><h2 id="Exoplayer缓存Cache"><a href="#Exoplayer缓存Cache" class="headerlink" title="Exoplayer缓存Cache"></a>Exoplayer缓存Cache</h2><p><a href="https://blog.csdn.net/john_chedan/article/details/80692483">缓存实现</a></p><p><a href="https://www.programcreek.com/java-api-examples/index.php?api=com.google.android.exoplayer2.upstream.cache.LeastRecentlyUsedCacheEvictor">缓存大小设置</a></p><p><a href="https://stackoverflow.com/questions/42073937/exoplayer-generalize-simplecache-behaviour">时效性变化的url处理</a></p><h2 id="Exoplayer源码修改"><a href="#Exoplayer源码修改" class="headerlink" title="Exoplayer源码修改"></a>Exoplayer源码修改</h2><p><a href="https://blog.csdn.net/u010302327/article/details/79788705">https://blog.csdn.net/u010302327/article/details/79788705</a></p><h2 id="IJKplayer"><a href="#IJKplayer" class="headerlink" title="IJKplayer"></a>IJKplayer</h2><p><a href="https://github.com/Bilibili/ijkplayer">官网</a></p><p><a href="https://www.jianshu.com/p/55fbfd5b564a">小结</a></p><p><a href="https://www.jianshu.com/p/220b00d00deb">问题集锦</a></p><h2 id="IJKplayer编译"><a href="#IJKplayer编译" class="headerlink" title="IJKplayer编译"></a>IJKplayer编译</h2><p><a href="https://www.jianshu.com/p/bd289e25d272">编译so支持HTTPS</a></p><p><a href="https://www.jianshu.com/p/2c1413486b01">编译so1</a></p><p><a href="https://blog.csdn.net/zy987654zy/article/details/53126457">编译so2</a></p><h2 id="IJKplayer关于卡顿的Github-Issue"><a href="#IJKplayer关于卡顿的Github-Issue" class="headerlink" title="IJKplayer关于卡顿的Github Issue"></a>IJKplayer关于卡顿的Github Issue</h2><p><a href="https://github.com/Bilibili/ijkplayer/issues/3179">https://github.com/Bilibili/ijkplayer/issues/3179</a></p><p><a href="https://github.com/Bilibili/ijkplayer/issues/3048">https://github.com/Bilibili/ijkplayer/issues/3048</a></p><p><a href="https://github.com/Bilibili/ijkplayer/issues/4094">https://github.com/Bilibili/ijkplayer/issues/4094</a></p><p><a href="https://github.com/Bilibili/ijkplayer/issues/4319">https://github.com/Bilibili/ijkplayer/issues/4319</a></p><p><a href="https://github.com/Bilibili/ijkplayer/issues/3493">https://github.com/Bilibili/ijkplayer/issues/3493</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android实习笔记</title>
    <link href="/2018/09/12/Andorid%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2018/09/12/Andorid%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>⚠️ 杂乱无章链接且极大可能打不开</p><h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><p>Git 是流行的代码版本控制系统，Gerrit是代码审核系统，实现Web界面上的代码版本控制。</p><p>git checkout 撤销修改，让工作区文件回到最近一次 git commit 或 git add 时的状态</p><h4 id="JAVA多线程访问同一个可变变量，需增加同步机制"><a href="#JAVA多线程访问同一个可变变量，需增加同步机制" class="headerlink" title="JAVA多线程访问同一个可变变量，需增加同步机制"></a>JAVA多线程访问同一个可变变量，需增加同步机制</h4><p>JVM中存在一个主内存(Java Heap Memory)，Java 中所有变量都储存在主内存中，对于所有线程都是共享的。</p><p>每个线程都有自己的工作内存 (Working Memory)，工作内存中保存的是主存中某些变量的拷贝，线程对所有变量的操作都是在工作内存中进行</p><p>线程之间无法相互直接访问，变量传递均需要通过主内存完成。</p><p>根据上述内存模型的定义，要在多个线程间安全的同步共享数据就必须使用锁机制，将某线程中更新的数据从其工作内存中刷新至主内存，并确保其他线程从主内存获取此数据更新后的值再使用</p><h4 id="使用-System-arraycopy-进行数组复制"><a href="#使用-System-arraycopy-进行数组复制" class="headerlink" title="使用 System.arraycopy() 进行数组复制"></a>使用 System.arraycopy() 进行数组复制</h4><p>在将一个数组对象复制成另外一个数组对象时，不要自己使用循环复制，可以使用JAVA提供的System.arraycopy() 功能来复制数据对象，避免出错，效率更高</p><h4 id="aar库文件和-jar库文件的区别"><a href="#aar库文件和-jar库文件的区别" class="headerlink" title=".aar库文件和.jar库文件的区别"></a>.aar库文件和.jar库文件的区别</h4><p>aar 文件是建立在 jar 文件的基础之上， aar 是 jar 文件的一个变种。本质上没有什么区别，都是压缩包，<strong>只是能包含的内容不一样</strong>。</p><ul><li>jar 只包含了 class 文件与清单文件。虽然也能包含资源文件，但不过是文本资源和图片资源，不能包含 Android 平台下的 drawable 以及各种 xml 文件.</li><li>aar 包括的东西更多一些，包含所有资源文件、第三方库文件、so 文件、class 以及 res 资源文件全部包含。</li></ul><h4 id="Android接口回调机制"><a href="#Android接口回调机制" class="headerlink" title="Android接口回调机制"></a>Android接口回调机制</h4><p>接口回调的意思即，注册之后并不立马执行，而在某个时机触发执行 。</p><p>回调方法就是一个通过方法指针来调用的方法（接口），如果我将这个方法的指针（地址，引用）通过形参传递到另一个类的某个方法里（setCallBack 注册），那么当这个类调用该方法里面我所传入的指针时，就能调用我这边的方法。 </p><p>整个过程就是我传入方法 A 的地址，你接收，并在某个时刻回调我这边的 A 方法。由于 Java 没办法操作指针，于是它用接口来实现。 </p><p>主要步骤如下：</p><ul><li>定义接口 Callback ,包含回调方法 callback()；</li><li>B 类提供注册的方法，并设定在某个条件下会回调接口方法；</li><li>A 类提供接口的实现方法，并注册到 B 类，把方法地址传进去。</li></ul><p>这样,在需要的时候,可用 CamCallback 接口成员调用 callback() 方法,完成回调了。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BService</span> </span>&#123;<br>    <br><span class="hljs-keyword">private</span> OnParserCallBack callBack;<br>    <span class="hljs-comment">//B类中定义接口定义回调方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OnParserCallBack</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnParserComplete</span><span class="hljs-params">(List&lt;HoursWeatherBean&gt; list,</span></span><br><span class="hljs-params"><span class="hljs-function">PMBean pmBean, WeatherBean weatherBean)</span></span>;<br>&#125;<br><span class="hljs-comment">//注册用于接收A类传递过来数据</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCallBack</span><span class="hljs-params">(OnParserCallBack callback)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.callBack = callback;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeCallback</span><span class="hljs-params">()</span></span>&#123;<br>callBack = <span class="hljs-keyword">null</span>;<br>&#125;<br>      <br>    <span class="hljs-comment">//dosomething()</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getCityWeather</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span>(callBack!=<span class="hljs-keyword">null</span>)&#123;<br>    <span class="hljs-comment">//这里使用的是A类传递的数据</span><br>callBack.OnParserComplete(list, pmBean, weatherBean);<br><br>&#125;<br> <br>&#125;<br> <br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Amain</span></span>&#123;<br>     <span class="hljs-keyword">private</span> BService mbService;<br> <span class="hljs-comment">//注册</span><br> mbService.setCallBack(<span class="hljs-keyword">new</span> OnParserCallBack()&#123;<br>    <span class="hljs-comment">//回调方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnParserComplete</span><span class="hljs-params">(List&lt;HoursWeatherBean&gt; list, PMBean pmBean,</span></span><br><span class="hljs-params"><span class="hljs-function">WeatherBean weatherBean)</span> </span>&#123;<br><span class="hljs-comment">//接收数据后开始用于显示</span><br>setHourViews(list);<br>setPmViews(pmBean);<br>setWeather(weatherBean);<br>&#125;<br>   &#125;);<br> mbService.getCityWeather();<br>&#125;<br></code></pre></td></tr></table></figure><p>另外的网页参考：</p><p><a href="http://www.apkbus.com/thread-589290-1-1.html">http://www.apkbus.com/thread-589290-1-1.html</a></p><p><a href="https://www.jianshu.com/p/f05730ab5d05">https://www.jianshu.com/p/f05730ab5d05</a></p><h4 id="EditText-不换行"><a href="#EditText-不换行" class="headerlink" title="EditText 不换行"></a>EditText 不换行</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">android:singleLine=&quot;true&quot;<br></code></pre></td></tr></table></figure><h4 id="Java-中-int-转-String-的三种方式"><a href="#Java-中-int-转-String-的三种方式" class="headerlink" title="Java 中 int 转 String 的三种方式"></a>Java 中 int 转 String 的三种方式</h4><ol><li>a+”“  这种效率最低</li><li>String.valueOf(a)</li><li>Integer.toString(a)</li></ol><h4 id="牛逼的-material-dialogs"><a href="#牛逼的-material-dialogs" class="headerlink" title="牛逼的 material-dialogs"></a>牛逼的 material-dialogs</h4><p><a href="https://github.com/afollestad/material-dialogs">https://github.com/afollestad/material-dialogs</a></p><h4 id="解决支持库版本兼容问题"><a href="#解决支持库版本兼容问题" class="headerlink" title="解决支持库版本兼容问题"></a>解决支持库版本兼容问题</h4><p>如果引用的第三方库的支持库版本低于（或者不一致）app build.gradle 中的支持库版本，可能会出现如下问题：</p><p>all com.android.support libraries must use the exact same version specification(mixing versions can lead to runtime crashes)</p><p>去改第三方库所用的支持库版本比较麻烦，如果用的库很多的话工作量很大。这个时候我们可以考虑强制让所有模块都用相同的支持库版本。</p><p>在 app build.gradle 中添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">configurations.all &#123;<br>    resolutionStrategy.eachDependency &#123; DependencyResolveDetails details -&gt;<br>        def requested = details.<span class="hljs-function">requested</span><br><span class="hljs-function">        <span class="hljs-title">if</span> <span class="hljs-params">(requested.group == <span class="hljs-string">&#x27;com.android.support&#x27;</span>)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (!requested.name.startsWith(<span class="hljs-string">&quot;multidex&quot;</span>)) &#123;<br>                details.useVersion <span class="hljs-string">&#x27;26.0.1&#x27;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="TextView滚动设置"><a href="#TextView滚动设置" class="headerlink" title="TextView滚动设置"></a>TextView滚动设置</h4><p>只要在布局的 xml 文件中设置 TextView 的属性：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">android:</span>maxLines = <span class="hljs-string">&quot;AN_INTEGER&quot;</span><br><br><span class="hljs-symbol">android:</span>scrollbars = <span class="hljs-string">&quot;vertical&quot;</span><br></code></pre></td></tr></table></figure><p>然后在代码中用：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">yourTextView.setMovementMethod(<span class="hljs-keyword">new</span> <span class="hljs-type">ScrollingMovementMethod</span>())<br></code></pre></td></tr></table></figure><p>它可以自由的滚动了。</p><h4 id="Android-文件下载三种基本方式"><a href="#Android-文件下载三种基本方式" class="headerlink" title="Android 文件下载三种基本方式"></a>Android 文件下载三种基本方式</h4><h5 id="1-自己封装-URLConnection-连接请求类"><a href="#1-自己封装-URLConnection-连接请求类" class="headerlink" title="1.自己封装 URLConnection 连接请求类"></a>1.自己封装 URLConnection 连接请求类</h5><p>这种方式在 Android 刚兴起的时候，很少下载封装框架，就自己封装了。虽然一般的文件都能下载，但这种方式缺点很多，不稳定或者各种各样的问题会出现。 </p><h5 id="2-Android-自定的下载管理（会在-notification-显示下载的进度，同时可以暂停、重新连接等）"><a href="#2-Android-自定的下载管理（会在-notification-显示下载的进度，同时可以暂停、重新连接等）" class="headerlink" title="2.Android 自定的下载管理（会在 notification 显示下载的进度，同时可以暂停、重新连接等）"></a>2.Android 自定的下载管理（会在 notification 显示下载的进度，同时可以暂停、重新连接等）</h5><p>这种方式其实就是交给了 Android 系统的另一个 app 去下载管理。这样的好处不会消耗该APP 的 CPU 资源。缺点是：控制起来很不灵活。 </p><p><a href="https://www.jianshu.com/p/46fd1c253701">https://www.jianshu.com/p/46fd1c253701</a></p><p><a href="https://www.cnblogs.com/gooder2-android/p/8966045.html">https://www.cnblogs.com/gooder2-android/p/8966045.html</a></p><h5 id="3-使用第三方-okhttp-网络请求框架"><a href="#3-使用第三方-okhttp-网络请求框架" class="headerlink" title="3.使用第三方 okhttp 网络请求框架"></a>3.使用第三方 okhttp 网络请求框架</h5><p>okhttp 是一个很有名气的开源框架，目前已经很多大公司都直接使用它作为网络请求库（七牛云 SDK， 阿里云 SDK）。 且里面集成了很多优势，包括 okio (一个 I/O 框架，优化内存与  CPU)。</p><p>综合来看，第三种方案是最佳的，是目前最流行的下载方案。</p><p>第三方框架还研究了封装 okhttp 的<a href="https://github.com/jeasonlzy/okhttp-OkGo">OKgo</a></p><p><a href="https://github.com/AriaLyy/Aria">Aria</a>  </p><h4 id="Android-6-0-以上文件读写权限"><a href="#Android-6-0-以上文件读写权限" class="headerlink" title="Android 6.0 以上文件读写权限"></a>Android 6.0 以上文件读写权限</h4><p>除了在清单文件中声明权限，还需要在访问文件时动态申请权限</p><h5 id="1、AndroidManifest-xml-文件添加"><a href="#1、AndroidManifest-xml-文件添加" class="headerlink" title="1、AndroidManifest.xml 文件添加:"></a>1、AndroidManifest.xml 文件添加:</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="2、onCreate-或其他访问文件位置添加授权"><a href="#2、onCreate-或其他访问文件位置添加授权" class="headerlink" title="2、onCreate() 或其他访问文件位置添加授权"></a>2、onCreate() 或其他访问文件位置添加授权</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkPermission</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//检查权限（NEED_PERMISSION）是否被授权 PackageManager.PERMISSION_GRANTED表示同意授权</span><br>    <span class="hljs-keyword">if</span> (ActivityCompat.checkSelfPermission(<span class="hljs-keyword">this</span>, Manifest.permission.WRITE_EXTERNAL_STORAGE)<br>            != PackageManager.PERMISSION_GRANTED) &#123;<br>        <span class="hljs-comment">//用户已经拒绝过一次，再次弹出权限申请对话框需要给用户一个解释</span><br>        <span class="hljs-keyword">if</span> (ActivityCompat.shouldShowRequestPermissionRationale(<span class="hljs-keyword">this</span>, Manifest.permission<br>                .WRITE_EXTERNAL_STORAGE)) &#123;<br>            Toast.makeText(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;请开通相关权限，否则无法正常使用本应用！&quot;</span>, Toast.LENGTH_SHORT).show();<br>        &#125;<br>        <span class="hljs-comment">//申请权限</span><br>        ActivityCompat.requestPermissions(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, REQUEST_WRITE_EXTERNAL_STORAGE);<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Toast.makeText(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;授权成功！&quot;</span>, Toast.LENGTH_SHORT).show();<br>        Log.e(TAG_SERVICE, <span class="hljs-string">&quot;checkPermission: 已经授权！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 没有第二步的话需要自己去手机的应用程序设置手动允许权限。</p><h4 id="Android-7-0-FileProvider-问题"><a href="#Android-7-0-FileProvider-问题" class="headerlink" title="Android 7.0 FileProvider 问题"></a>Android 7.0 FileProvider 问题</h4><p><a href="https://blog.csdn.net/growing_tree/article/details/71190741">https://blog.csdn.net/growing_tree/article/details/71190741</a></p><h4 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h4><p>Java的新特性，目的是使得代码更加简洁，只有一个待实现方法的接口，都可以使用 Lambda表达式的写法，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// λ</span><br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> Runnable()&#123;<br>　　<span class="hljs-meta">@Override</span><br>　　<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>　　&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>转成 Lanbda 表达式就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> ()-&gt;&#123;&#125;;<br></code></pre></td></tr></table></figure><p>如需为您的项目启用 Java 8 语言功能和 Jack，请在模块层级的 build.gradle 文件中输入以下内容： </p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-class">android </span>&#123;<br>  ...<br>  <span class="hljs-class">defaultConfig </span>&#123;<br>    ...<br>    <span class="hljs-class">jackOptions </span>&#123;<br>      enabled true<br>    &#125;<br>  &#125;<br>  <span class="hljs-class">compileOptions </span>&#123;<br>    sourceCompatibility JavaVersion.VERSION_1_8<br>    targetCompatibility JavaVersion.VERSION_1_8<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Jsoup-安卓端的爬虫"><a href="#Jsoup-安卓端的爬虫" class="headerlink" title="Jsoup 安卓端的爬虫"></a>Jsoup 安卓端的爬虫</h4><p>加库后用三行代码，即可获得应用名到应用包名的转换。感谢酷安</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Document doc = Jsoup.connect(<span class="hljs-string">&quot;https://www.coolapk.com/search?q=&quot;</span>+pack_name).get();<br>Elements res =doc.select(<span class="hljs-string">&quot;#game_left &gt; div &gt; a:nth-child(2)&quot;</span>);<br>String ss = res.attr(<span class="hljs-string">&quot;href&quot;</span>).substring(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><h4 id="解决网络请求多线程的骚操作"><a href="#解决网络请求多线程的骚操作" class="headerlink" title="解决网络请求多线程的骚操作"></a>解决网络请求多线程的骚操作</h4><p>问题是：如何让主线程等待子线程获得网络数据后再继续运行？  </p><p>设网络数据为全局变量 x，再设一个全局 flag 变量。设全局变量是为了让变量可访问，但不知会否引起安全和效率问题。</p><p>主线程设置 flag 变量的死循环，子线程执行网络请求，成功修改 x 完毕再修改 flag 变量，使得主线程离开死循环继续执行。这时，主线程就能使用到存储了网络数据的 x 变量。（机智）</p><p><a href="https://bbs.csdn.net/topics/391838191">https://bbs.csdn.net/topics/391838191</a></p><h4 id="AsyncTask-优点缺点"><a href="#AsyncTask-优点缺点" class="headerlink" title="AsyncTask 优点缺点"></a>AsyncTask 优点缺点</h4><p>优点：简单快捷</p><p>缺点：后台真正只有一个线程，多线程是串行执行的</p><p><a href="https://blog.csdn.net/evan123mg/article/details/52960339">https://blog.csdn.net/evan123mg/article/details/52960339</a></p><h4 id="Handler学习"><a href="#Handler学习" class="headerlink" title="Handler学习"></a>Handler学习</h4><p><a href="https://blog.csdn.net/u010177022/article/details/63278070">https://blog.csdn.net/u010177022/article/details/63278070</a></p><p><a href="https://blog.csdn.net/songmingzhan/article/details/78408383">https://blog.csdn.net/songmingzhan/article/details/78408383</a></p><p><a href="https://www.cnblogs.com/ryanleee/p/8204450.html">https://www.cnblogs.com/ryanleee/p/8204450.html</a></p><p><a href="https://www.cnblogs.com/android007/archive/2012/05/10/2494766.html">https://www.cnblogs.com/android007/archive/2012/05/10/2494766.html</a></p><p>避免内存泄漏</p><p><a href="https://www.cnblogs.com/JohnTsai/p/5259869.html">https://www.cnblogs.com/JohnTsai/p/5259869.html</a></p><h4 id="主线程给子线程传参数"><a href="#主线程给子线程传参数" class="headerlink" title="主线程给子线程传参数"></a>主线程给子线程传参数</h4><p><a href="https://blog.csdn.net/choubaoguai/article/details/23671441">https://blog.csdn.net/choubaoguai/article/details/23671441</a></p><ol><li><p>构造函数传递数据</p><p>定义一个线程类，扩展 Thread，增加一个成员变量，用来保存传进来的参数。新加一个拷贝构造函数，拷贝写入到成员变量。</p></li><li><p>变量和方法传递数据</p></li><li><p>回调函数</p></li></ol><h4 id="ADB-快捷从电脑安装apk到手机"><a href="#ADB-快捷从电脑安装apk到手机" class="headerlink" title="ADB 快捷从电脑安装apk到手机"></a>ADB 快捷从电脑安装apk到手机</h4><p>打开 cmd，输入指令，路径可以直接从资源管理器拖过去</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">adb <span class="hljs-keyword">install</span> -r 路径<br></code></pre></td></tr></table></figure><h4 id="注解：编译时注解和运行时注解"><a href="#注解：编译时注解和运行时注解" class="headerlink" title="注解：编译时注解和运行时注解"></a>注解：编译时注解和运行时注解</h4><p><a href="http://www.mamicode.com/info-detail-1317919.html">http://www.mamicode.com/info-detail-1317919.html</a></p><p><a href="http://www.importnew.com/1796.html">http://www.importnew.com/1796.html</a></p><h4 id="动态权限申请"><a href="#动态权限申请" class="headerlink" title="动态权限申请"></a>动态权限申请</h4><p><a href="https://github.com/mylhyl/AndroidAcp">https://github.com/mylhyl/AndroidAcp</a></p><h4 id="Android-存储路径"><a href="#Android-存储路径" class="headerlink" title="Android 存储路径"></a>Android 存储路径</h4><p>补充：对于现在市面上很多 Android 设备，自带了一个大的存储空间，一般是 8GB 或 16GB，并且又支持了 sdCard 扩展，对于这样的设备，使用 Enviroment.getExternalStorageDirectory() 方法只能获取到设备自带的存储空间，对于另外扩展的 sdCard 而言，需要修改路径。 </p><p>保存到应用的内部文件夹——在 “Android/Data/应用包名/…”路径下，卸载应用时也会一并清除</p><p>通过 getExternalFilesDir() 方法可以获取到 SDCard/Android/data/你的应用的包名/files/ 目录，一般放一些长时间保存的数据 </p><p>通过 getExternalCacheDir() 方法可以获取到 SDCard/Android/data/你的应用包名/cache/目录，一般存放临时缓存数据 </p><p>应用外部的话，可以用 Environment.getExternalStorageDirectory() 来索取到默认内置存储的根路径，即 “/storage/emulated/0”，这种情况下卸载应用时不会清除哦 </p><h4 id="Handler-理解源码分析"><a href="#Handler-理解源码分析" class="headerlink" title="Handler 理解源码分析"></a>Handler 理解源码分析</h4><p><a href="https://blog.csdn.net/lishuangling21/article/details/70767586">https://blog.csdn.net/lishuangling21/article/details/70767586</a></p><h4 id="获取-Android-手机里所有已安装的APP"><a href="#获取-Android-手机里所有已安装的APP" class="headerlink" title="获取 Android 手机里所有已安装的APP"></a>获取 Android 手机里所有已安装的APP</h4><p><a href="https://blog.csdn.net/lishuangling21/article/details/50789715">https://blog.csdn.net/lishuangling21/article/details/50789715</a></p><h4 id="Eclipse-copy-风格的快捷键"><a href="#Eclipse-copy-风格的快捷键" class="headerlink" title="Eclipse copy 风格的快捷键"></a>Eclipse copy 风格的快捷键</h4><p>ctrl+H 找有没有引用</p><p>ctrl+shift+R 进入文件的资源管理器路径</p><h4 id="项目恢复"><a href="#项目恢复" class="headerlink" title="项目恢复"></a>项目恢复</h4><p>资源管理器中右键模块→ GIT → Revert →找到相应的模块项目恢复即可</p><h4 id="工程资源清理"><a href="#工程资源清理" class="headerlink" title="工程资源清理"></a>工程资源清理</h4><p><a href="https://blog.csdn.net/caoxiao90/article/details/51057986">https://blog.csdn.net/caoxiao90/article/details/51057986</a></p><p>打开 AS，点击工具栏的 Analyze-Run Inspection by Name-输入 unused resources-选择要搜索的范围回车-查看搜索结果并删除无用的资源文件 </p><p>出来运行结果后，展开到最小条目后，双击打开文件，再在资源管理器右上方点击多重圆圈按钮 “Scroll from source”，定位到具体文件夹，注意最好要在 Android 视图方式打开，可以合并同类资源到同一个文件夹下面，然后直接删除文件夹可以一次性删除多个。删除时要选中 Safe search，会进行再次检查有没有 usage，最后才确认是否删除</p><p>在 Version Control 中可以找到改动，便于检查</p><p>确保效果和不出差错，善于利用 ctrl+H 找有没有引用和 ctrl+shift+R 进入文件的资源管理器路径</p><h4 id="【Android-珍藏】推荐10个炫酷的开源库"><a href="#【Android-珍藏】推荐10个炫酷的开源库" class="headerlink" title="【Android 珍藏】推荐10个炫酷的开源库"></a>【Android 珍藏】推荐10个炫酷的开源库</h4><p><a href="https://juejin.im/post/5b50898ef265da0fa21a7f0f">https://juejin.im/post/5b50898ef265da0fa21a7f0f</a></p><h4 id="ButterKnife-BindView-时报-Required-view-ID-was-not-found-异常"><a href="#ButterKnife-BindView-时报-Required-view-ID-was-not-found-异常" class="headerlink" title="ButterKnife@BindView 时报 Required view ID was not found 异常"></a>ButterKnife@BindView 时报 Required view ID was not found 异常</h4><p>解决思路：在 @BindView 前面加上 @Nullable 或者 @Optional</p><h4 id="BottomNavigationView-的相关网页"><a href="#BottomNavigationView-的相关网页" class="headerlink" title="BottomNavigationView 的相关网页"></a>BottomNavigationView 的相关网页</h4><p><a href="https://blog.csdn.net/yihuangol/article/details/74370289">https://blog.csdn.net/yihuangol/article/details/74370289</a></p><p><a href="https://blog.csdn.net/xiaoyangsavvy/article/details/70213537">https://blog.csdn.net/xiaoyangsavvy/article/details/70213537</a></p><h4 id="Fragment-使用"><a href="#Fragment-使用" class="headerlink" title="Fragment 使用"></a>Fragment 使用</h4><p><a href="https://www.jianshu.com/p/fd71d65f0ec6">https://www.jianshu.com/p/fd71d65f0ec6</a></p><h4 id="开发要点"><a href="#开发要点" class="headerlink" title="开发要点"></a>开发要点</h4><p>所有变量声明放在最外面，初始化看情况而定，List，arrarylist 这些可以声明时就初始化，直接 new…</p><h4 id="Butterknife-和-reclclerview-的综合用法"><a href="#Butterknife-和-reclclerview-的综合用法" class="headerlink" title="Butterknife 和 reclclerview 的综合用法"></a>Butterknife 和 reclclerview 的综合用法</h4><p><a href="https://www.aliyun.com/jiaocheng/15082.html">https://www.aliyun.com/jiaocheng/15082.html</a></p><h4 id="RecyclerView-点击事件接口回调"><a href="#RecyclerView-点击事件接口回调" class="headerlink" title="RecyclerView 点击事件接口回调"></a>RecyclerView 点击事件接口回调</h4><p><a href="https://blog.csdn.net/willba/article/details/72878345">https://blog.csdn.net/willba/article/details/72878345</a></p><p><a href="https://blog.csdn.net/weikai_/article/details/78936013">https://blog.csdn.net/weikai_/article/details/78936013</a></p><p><a href="https://blog.csdn.net/xieluoxixi/article/details/61924372">https://blog.csdn.net/xieluoxixi/article/details/61924372</a></p><p><a href="https://blog.csdn.net/dl10210950/article/details/52918019">https://blog.csdn.net/dl10210950/article/details/52918019</a></p><h4 id="获取-RecyclerView-的-Item-中的-EditText-的内容"><a href="#获取-RecyclerView-的-Item-中的-EditText-的内容" class="headerlink" title="获取 RecyclerView 的 Item 中的 EditText 的内容"></a>获取 RecyclerView 的 Item 中的 EditText 的内容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">EditText TmpEditText= (EditText)mRecyclerView.getChildAt(position).findViewById(R.id.app_input);<br>String app_name= TmpEditText.getText().toString();<br></code></pre></td></tr></table></figure><h4 id="透明背景文字图片做法"><a href="#透明背景文字图片做法" class="headerlink" title="透明背景文字图片做法"></a>透明背景文字图片做法</h4><p>利用ppt，确定文字效果以后再复制，左上角找到选择性粘贴，选中 “PNG图片”，图片粘贴在PPT上面后再另存为图片保存为 PNG 格式，保存到资源文件管理器中</p><h4 id="RecyclerView-复用问题，坑大半天的问题"><a href="#RecyclerView-复用问题，坑大半天的问题" class="headerlink" title="RecyclerView 复用问题，坑大半天的问题"></a>RecyclerView 复用问题，坑大半天的问题</h4><p>onBindViewHolder 会有多次调用重绘，if-else 条件必须确保完整。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(ViewHolder holder, <span class="hljs-keyword">int</span> position)</span> </span>&#123;<br><br>    holder.app_icon.setImageDrawable(app_list.get(position).getImage());<br>    holder.app_name.setText(app_list.get(position).getName());<br>    <span class="hljs-keyword">if</span> (app_list.get(position).getIsHasUpdate()==<span class="hljs-keyword">false</span>)&#123;<br>        holder.isHasUpdate.setVisibility(View.GONE);<br>    &#125;<br>    <span class="hljs-comment">//一定必须要加下面的else</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        holder.isHasUpdate.setVisibility(View.VISIBLE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/csdn_aiyang/article/details/80094302">https://blog.csdn.net/csdn_aiyang/article/details/80094302</a></p><p><a href="https://blog.csdn.net/like_program/article/details/52517119">https://blog.csdn.net/like_program/article/details/52517119</a></p><h4 id="SwipeRefreshLayout-使用"><a href="#SwipeRefreshLayout-使用" class="headerlink" title="SwipeRefreshLayout 使用"></a>SwipeRefreshLayout 使用</h4><p><a href="https://www.jianshu.com/p/d23b42b6360b">https://www.jianshu.com/p/d23b42b6360b</a></p><p><a href="https://blog.csdn.net/yl104221034/article/details/50582644">https://blog.csdn.net/yl104221034/article/details/50582644</a></p><h4 id="ImageButton-背景透明"><a href="#ImageButton-背景透明" class="headerlink" title="ImageButton 背景透明"></a>ImageButton 背景透明</h4><p>xml里面设置 android:background=”@null”</p><h4 id="坑爹-RecyclerView-获取子-Item-位置问题"><a href="#坑爹-RecyclerView-获取子-Item-位置问题" class="headerlink" title="坑爹 RecyclerView 获取子 Item 位置问题"></a>坑爹 RecyclerView 获取子 Item 位置问题</h4><p>getChildAt 函数只能获取屏幕可见的子 Item</p><p><a href="https://blog.csdn.net/binbin960211892/article/details/78662388">https://blog.csdn.net/binbin960211892/article/details/78662388</a></p><p><a href="https://blog.csdn.net/higson/article/details/52819327">https://blog.csdn.net/higson/article/details/52819327</a></p><h4 id="跳转应用市场详情界面查看"><a href="#跳转应用市场详情界面查看" class="headerlink" title="跳转应用市场详情界面查看"></a>跳转应用市场详情界面查看</h4><p><a href="https://www.jianshu.com/p/a4a806567368">https://www.jianshu.com/p/a4a806567368</a></p><h4 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h4><p><a href="https://blog.csdn.net/qq_21194621/article/details/51627274">https://blog.csdn.net/qq_21194621/article/details/51627274</a></p><p><a href="https://blog.csdn.net/zzh12138/article/details/71077909">https://blog.csdn.net/zzh12138/article/details/71077909</a></p><p><a href="https://blog.csdn.net/sinat_33585352/article/details/80741648">https://blog.csdn.net/sinat_33585352/article/details/80741648</a></p><h4 id="计算-App-占用空间"><a href="#计算-App-占用空间" class="headerlink" title="计算 App 占用空间"></a>计算 App 占用空间</h4><p><a href="https://blog.csdn.net/bingqingsuimeng/article/details/51062300">https://blog.csdn.net/bingqingsuimeng/article/details/51062300</a></p><p><a href="https://blog.csdn.net/m6711154/article/details/52000041">https://blog.csdn.net/m6711154/article/details/52000041</a></p><h4 id="避免代码复用出现问题"><a href="#避免代码复用出现问题" class="headerlink" title="避免代码复用出现问题"></a>避免代码复用出现问题</h4><p>setVisibility 为不可见之后要注意判断后面还有没有复用，添加 if 判断重新设置为可见</p><h4 id="文件扫描搜索"><a href="#文件扫描搜索" class="headerlink" title="文件扫描搜索"></a>文件扫描搜索</h4><p><a href="https://blog.csdn.net/yuzhiqiang_1993/article/details/78140580">https://blog.csdn.net/yuzhiqiang_1993/article/details/78140580</a></p><h4 id="通过媒体库提供方式实现文件扫描搜索"><a href="#通过媒体库提供方式实现文件扫描搜索" class="headerlink" title="通过媒体库提供方式实现文件扫描搜索"></a>通过媒体库提供方式实现文件扫描搜索</h4><p><a href="https://www.jianshu.com/p/a6bdbefde77a">https://www.jianshu.com/p/a6bdbefde77a</a></p><p><a href="https://blog.csdn.net/zocki33250/article/details/48112669">https://blog.csdn.net/zocki33250/article/details/48112669</a></p><p><a href="https://blog.csdn.net/yaochangliang159/article/details/51878841">https://blog.csdn.net/yaochangliang159/article/details/51878841</a></p><h4 id="RecyclerView-完美实现拖拽，滑动删除，撤销删除"><a href="#RecyclerView-完美实现拖拽，滑动删除，撤销删除" class="headerlink" title="RecyclerView 完美实现拖拽，滑动删除，撤销删除"></a>RecyclerView 完美实现拖拽，滑动删除，撤销删除</h4><p><a href="https://blog.csdn.net/hymanme/article/details/50931082">https://blog.csdn.net/hymanme/article/details/50931082</a></p><h4 id="SurfaceView-用处，用法"><a href="#SurfaceView-用处，用法" class="headerlink" title="SurfaceView 用处，用法"></a>SurfaceView 用处，用法</h4><p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2012/1201/656.html">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2012/1201/656.html</a></p><p><a href="https://blog.csdn.net/ShanYu1198124123/article/details/52448586">https://blog.csdn.net/ShanYu1198124123/article/details/52448586</a></p><h4 id="SurfaceView-和-TextureView-对比"><a href="#SurfaceView-和-TextureView-对比" class="headerlink" title="SurfaceView 和 TextureView 对比"></a>SurfaceView 和 TextureView 对比</h4><p><a href="https://blog.csdn.net/hejjunlin/article/details/58582919">https://blog.csdn.net/hejjunlin/article/details/58582919</a></p><p>我的思路是用 MediaPlayer 和 TextureView 来结合实现。（VideoView底层用的也是MediaPlayer，至于为什么不用 SurfaceView 而用 TextureView，是因为 SurfaceView不能放在可滑动的控件中，至于具体原因和缺点如果不清楚可自行百度之，TextureView 正是为了解决这个问题而存在的。</p><p>在 Android 总播放视频可以直接使用<code>VideoView</code>，<code>VideoView</code>是通过继承自<code>SurfaceView</code>来实现的。<code>SurfaceView</code>的大概原理就是在现有<code>View</code>的位置上创建一个新的<code>Window</code>，内容的显示和渲染都在新的<code>Window</code>中。这使得<code>SurfaceView</code>的绘制和刷新可以在单独的线程中进行，从而大大提高效率。但是呢，由于<code>SurfaceView</code>的内容没有显示在<code>View</code>中而是显示在新建的<code>Window</code>中， 使得<code>SurfaceView</code>的显示不受<code>View</code>的属性控制，不能进行平移，缩放等变换，也不能放在其它<code>RecyclerView</code>或<code>ScrollView</code>中，一些<code>View</code>中的特性也无法使用。</p><h4 id="Mediaplayer换成Exoplayer的方法"><a href="#Mediaplayer换成Exoplayer的方法" class="headerlink" title="Mediaplayer换成Exoplayer的方法"></a>Mediaplayer换成Exoplayer的方法</h4><p>版本号 2.5版本以前为 r2.x.x，2.5版本以后为 2.x.x</p><p>了解两种播放器的状态转换和监听接口回调，多打日志观察回调过程。</p><p>学习接口的写法，就像这次项目的更换，在有 Mediaplayer 的地方换成 ExoPlayer 的对应方法即可。VideoPlayerController 的代码完全不用改。</p><h4 id="新优化集成问题"><a href="#新优化集成问题" class="headerlink" title="新优化集成问题"></a>新优化集成问题</h4><p>第一时间想到能否集成，集成开销，对 APK 包大小的影响，老机器版本兼容性，建立表格，拍摄小视频等确认效果对比。</p><h4 id="开源项目推荐的网址"><a href="#开源项目推荐的网址" class="headerlink" title="开源项目推荐的网址"></a>开源项目推荐的网址</h4><p><a href="https://www.ctolib.com/android/">https://www.ctolib.com/android/</a></p><h4 id="“-”-和-“equals”-有什么差别？"><a href="#“-”-和-“equals”-有什么差别？" class="headerlink" title="“==” 和 “equals” 有什么差别？"></a>“==” 和 “equals” 有什么差别？</h4><p>equals用于判断对象的内容是否相等，==运算符用于比较对象的引用是否一致</p><h4 id="Apk-反编译"><a href="#Apk-反编译" class="headerlink" title="Apk 反编译"></a>Apk 反编译</h4><p><a href="https://blog.csdn.net/s13383754499/article/details/78914592">https://blog.csdn.net/s13383754499/article/details/78914592</a></p><p><a href="https://www.cnblogs.com/spring87/p/4525647.html">https://www.cnblogs.com/spring87/p/4525647.html</a></p><h4 id="依赖源码不起作用？三大重置方法"><a href="#依赖源码不起作用？三大重置方法" class="headerlink" title="依赖源码不起作用？三大重置方法"></a>依赖源码不起作用？三大重置方法</h4><ul><li>clean project</li><li>Invalie Cache and restart</li><li>关掉instant run</li></ul><h4 id="CMD-Markdown编辑器"><a href="#CMD-Markdown编辑器" class="headerlink" title="CMD Markdown编辑器"></a>CMD Markdown编辑器</h4><p><a href="https://www.zybuluo.com/mdeditor">https://www.zybuluo.com/mdeditor</a></p><h4 id="So-文件兼容-CPU-架构"><a href="#So-文件兼容-CPU-架构" class="headerlink" title="So 文件兼容 CPU 架构"></a>So 文件兼容 CPU 架构</h4><p><a href="http://xuchongyang.com/2017/03/12/%E6%8E%A2%E5%AF%BB-Android-so-%E5%BA%93/">http://xuchongyang.com/2017/03/12/%E6%8E%A2%E5%AF%BB-Android-so-%E5%BA%93/</a></p><h4 id="Binary-XML-file-line-Error-inflating-class"><a href="#Binary-XML-file-line-Error-inflating-class" class="headerlink" title="Binary XML file line # : Error inflating class"></a>Binary XML file line # : Error inflating class</h4><p><a href="https://blog.csdn.net/huangxiaohu_coder/article/details/8497286">https://blog.csdn.net/huangxiaohu_coder/article/details/8497286</a></p><p><a href="https://blog.csdn.net/xiabing082/article/details/43487159">https://blog.csdn.net/xiabing082/article/details/43487159</a></p><h4 id="Complie-和-Provided-区别"><a href="#Complie-和-Provided-区别" class="headerlink" title="Complie 和 Provided 区别"></a>Complie 和 Provided 区别</h4><p>Provided只是IDE编译时依赖，但是不打包到APK，也就是说编译时通过，但是不保证手机安装APK后是否能运行。</p><h4 id="TextView-优化"><a href="#TextView-优化" class="headerlink" title="TextView 优化"></a>TextView 优化</h4><p><a href="http://codethink.me/2015/04/23/improving-comment-rendering-on-android/">http://codethink.me/2015/04/23/improving-comment-rendering-on-android/</a></p><h4 id="视频基础知识"><a href="#视频基础知识" class="headerlink" title="视频基础知识"></a>视频基础知识</h4><p><a href="https://blog.csdn.net/zhs4430169/article/details/76502217">https://blog.csdn.net/zhs4430169/article/details/76502217</a></p><h4 id="Android-性能优化"><a href="#Android-性能优化" class="headerlink" title="Android 性能优化"></a>Android 性能优化</h4><p><a href="https://www.jianshu.com/p/307ba8911799">https://www.jianshu.com/p/307ba8911799</a></p><h4 id="DNS-优化"><a href="#DNS-优化" class="headerlink" title="DNS 优化"></a>DNS 优化</h4><p><a href="https://my.oschina.net/sudujuncom/blog/874699">https://my.oschina.net/sudujuncom/blog/874699</a></p><h4 id="修改第三方库"><a href="#修改第三方库" class="headerlink" title="修改第三方库"></a>修改第三方库</h4><p>final 类型的不可继承修改</p><p>继承要修改的类，右键新类名可以 generate 构造函数。再 @Override 具体修改的函数，记得要 super 父类函数</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>利用DNS隧道免认证上网</title>
    <link href="/2018/07/10/%E5%88%A9%E7%94%A8DNS%E9%9A%A7%E9%81%93%E5%85%8D%E8%AE%A4%E8%AF%81%E4%B8%8A%E7%BD%91/"/>
    <url>/2018/07/10/%E5%88%A9%E7%94%A8DNS%E9%9A%A7%E9%81%93%E5%85%8D%E8%AE%A4%E8%AF%81%E4%B8%8A%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<p>现在很多商场、饭店的商业WIFI采用了WEB Portal认证方式，但有些认证系统存在漏洞，可以利用 DNS 隧道绕过网关计费系统，实现上网。</p><h2 id="DNS运行机制"><a href="#DNS运行机制" class="headerlink" title="DNS运行机制"></a>DNS运行机制</h2><p>DNS(Domain Name System)是“域名系统”的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，用于TCP/IP网络，提供将主机名和域名转换为IP地址的服务，举例就是把<code>www.qq.com</code>转换为IPV4地址119.147.15.13</p><p>DNS解析域名过程如下叙述：</p><ol><li>找浏览器缓存，当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）。</li><li>找系统缓存，当浏览器缓存中无域名对应IP则会自动检查用户计算机系统Hosts文件DNS缓存是否有该域名对应IP。</li><li>找路由器缓存，当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查，以上三步均为客服端的DNS缓存。</li><li>找ISP的DNS缓存，当在用户客服端查找不到域名对应IP地址，则将进入ISP DNS缓存中进行查询。比如你用的是电信的网络，则会进入电信的DNS缓存服务器中进行查找。</li><li>查询根域名服务器，当以上均未完成，则进入根服务器进行查询。全球仅有13台根域名服务器，1个主根域名服务器，其余12为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com）服务器IP告诉本地DNS服务器。</li><li>查询顶级域名服务器，顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的IP地址告诉本地DNS服务器。</li><li>查询主域名服务器，主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录。</li><li>保存结果到缓存，本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个IP地址与web服务器建立链接。</li></ol><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/surfingViaDNSTunnel/DNSProcess.png"></p><h2 id="DNS隧道原理"><a href="#DNS隧道原理" class="headerlink" title="DNS隧道原理"></a>DNS隧道原理</h2><p>DNS隧道从名字上来看就是利用DNS查询过程建立起隧道，传输数据。概括地讲，所谓 tunnel 就是把下一层（比如IPv4层）的包封装到上一层（比如 SSH，HTTP）或者同一层（比如IPv6层）的协议中进行传输，从而实现网络之间的穿透。</p><p>很明显，这种实现有个前提，那就是：发送端和接收端必须各有一个解析这种包的程序或者内核模块才能实现正常通信。DNS隧道技术简单来说就是将网络流量封装成DNS流量,再通过DNS的正常走向将流量传出来.这里的流量封装通常由一个客户端来完成,而降封装的DNS流量还原成正常的流量将由一个服务端来完成。 </p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/surfingViaDNSTunnel/Topology.png"></p><p>下面是利用DNS隧道连接外部网络时DNS解析的一个过程，由于防火墙并没有对dns协议做任何处理，所以我们可以通过这种方式向外网发送数据来穿透防火墙。</p><ol><li>向内部dns服务器发送一个查询xxx.com的请求，这个域名的控制权限是在自己手里的</li><li>内部dns服务器通过防火墙向根dns服务器发出查询请求</li><li>经过大量重定向后，DNS请求到达xxx.com的权威DNS服务器，该服务器处于自己的控制之下</li><li>请求查询的响应结果通过防火墙</li><li>响应结果返回到内部服务器</li><li>内部服务器将响应结果返回</li></ol><h2 id="Web-Portal的原理"><a href="#Web-Portal的原理" class="headerlink" title="Web Portal的原理"></a>Web Portal的原理</h2><p>Portal在英语中是入口的意思。Portal认证通常也称为Web认证，一般将Portal认证网站称为门户网站。未认证用户上网时，设备强制用户登录到特定站点，用户可以免费访问其中的服务。当用户需要使用互联网中的其它信息时，必须在门户网站进行认证，只有认证通过后才可以使用互联网资源。Portal业务可以为运营商提供方便的管理功能，门户网站可以开展广告、社区服务、个性化的业务等，使宽带运营商、设备提供商和内容服务提供商形成一个产业生态系统。</p><p>Portal的典型组网方式如下面拓扑图所示，它由五个基本要素组成：认证客户端、接入设备、Portal服务器、认证/计费服务器和安全策略服务器。</p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/surfingViaDNSTunnel/webPortalTopology.png"></p><p>Portal认证的基本过程如下：</p><ol><li><p>客户机首先通过DHCP协议获取到IP地址（也可以使用静态IP地址），但是客户使用获取到的IP地址并不能登上Internet，在认证通过前只能访问特定的IP地址，这个地址通常是PORTAL服务器的IP地址。采用Portal认证的接入设备必须具备这个能力。一般通过修改接入设备的访问控制表（ACL）可以做到。</p></li><li><p>用户登录到Portal Server后，可以浏览上面的内容，比如广告、新闻等免费信息，同时用户还可以在网页上输入用户名和密码，它们会被WEB客户端应用程序传给 Portal Server，再由Portal Server与NAS之间交互来实现用户的认证。</p></li><li><p>Portal Server在获得用户的用户名和密码外，还会得到用户的IP地址，以它为索引来标识用户。然后Portal Server 与NAS之间用Portal协议直接通信，而NAS又与RADIUS 服务器直接通信完成用户的认证和上线过程。因为安全问题，通常支持安全性较强的CHAP式认证。</p></li></ol><h2 id="设备及环境软件"><a href="#设备及环境软件" class="headerlink" title="设备及环境软件"></a>设备及环境软件</h2><table><thead><tr><th>设备</th><th align="center">环境软件</th></tr></thead><tbody><tr><td>本地主机</td><td align="center">Windows10，iodine0.7，ShadowSocks代理，OpenVpn2.3.10，XShell6</td></tr><tr><td>腾讯云主机</td><td align="center">CentOS，OpenVpn，ShadowSocks代理，iodined</td></tr><tr><td>阿里云域名</td><td align="center">域名解析设置</td></tr></tbody></table><h2 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h2><p>一般情况下，连接上路由器后，不经过其它操作直接输入别的网址打开，主机的数据包将从TCP端口发出，这时路由器网关发现主机没有经过Portal认证，立刻就拦截这个端口发出的数据包，其它端口同理也拦截，最后重定向至认证页面要求用户进行认证。</p><p>然而，世间万事都有例外。即使在不经过Portal认证的情况下，UDP的53端口发出的数据包也不会被网关拦截，而在这个端口上运行的就是DNS协议，DNS的解析功能依然正常，因此设法利用这个端口，在本地将上网的数据包伪装成DNS数据包，本地DNS自然无法解析这个伪装的DNS数据包，利用域名解析解析到远程的自己搭建的服务器上，在远程服务器上再还原出真实的上网数据包完成各种上网请求，最后整理响应数据伪装成DNS响应数据包，返回主机上还原查看上网响应数据包。</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="域名解析配置"><a href="#域名解析配置" class="headerlink" title="域名解析配置"></a>域名解析配置</h3><p>在阿里云上申请了一个.top域名，进入到域名控制台中，点击“解析”进入到解析配置，为域名添加一条A记录和一条NS记录，详情如下图所示。 </p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/surfingViaDNSTunnel/domainSetting.png"></p><p>其中A记录用来指定主机名或域名对应的IP地址记录，NS记录是域名服务器记录，用来指定该域名由哪个DNS服务器来进行解析。当本地域名服务器无法解析伪装的数据包后，便将数据包发送给NS记录指定的服务器aaa.coolcc.top，而aaa.coolcc.top的IP地址已经在A记录中给出了。</p><p>因此，这样配置后本地域名服务器会将伪装的DNS数据包发送到云主机上。</p><h3 id="云主机配置"><a href="#云主机配置" class="headerlink" title="云主机配置"></a>云主机配置</h3><p>在腾讯云上购买了体验云主机，配置为1 核 1 GB 1 Mbps，预装系统为CentOS 7.4 64位，可在控制台中查看到当前云主机概况，如下图所示。 </p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/surfingViaDNSTunnel/cloudServer.png"></p><p>在控制台菜单中进入到<code>安全组</code>选项，新建安全组，设置为<code>放通所有端口</code>，便于DNS数据在UDP53端口的接收传送。回到云主机概况中，点此云主机的<code>更多</code>，进入到<code>配置安全组选项</code>，将此安全组配置给云主机。 </p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/surfingViaDNSTunnel/newGroup.png"></p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/surfingViaDNSTunnel/setGroup.png"></p><p>使用XShell连接云主机，新建会话，在主机一栏中填入云主机的公网IP，随后弹出登录验证界面，输入用户账号密码后即可登录使用管理云主机。</p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/surfingViaDNSTunnel/xshellConnect.png"></p><p>登录云主机成功后就可以开始配置主机环境，安装DNS隧道所需软件，输入以下安装指令并依照提示安装即可</p><table><thead><tr><th><strong>软件</strong></th><th>安装指令</th><th>作用</th></tr></thead><tbody><tr><td>iodined</td><td>yum install iodine</td><td>建立DNS隧道</td></tr><tr><td>OpenVpn</td><td>yum install openvpn</td><td>虚拟网卡</td></tr><tr><td>ShadowSocks</td><td>yum install python-setuptools ; easy_install pip</td><td>系统代理</td></tr></tbody></table><p>安装完软件后需要配置软件，对于ShadowSocks，配置其代理设置，输入<code>vim /etc/shadowsocks.json</code>指令来创建配置文件，内容如下图，其中服务器地址填写的地址需要与云主机内网IP在同一个网段下，保存退出。随后输入<code>ssserver -c /etc/shadowsocks.json -d start</code>指令，表明用配置文件启动运行ShadowSocks服务。最后输入<code>iodined -c -f -P 12345678 172.16.99.1 zwc.coolcc.top</code>指令启动iodine，监听zwc.coolcc.top的DNS解析。 </p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/surfingViaDNSTunnel/shadowSocksSetting.png"></p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/surfingViaDNSTunnel/runShadowSocks.png"></p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/surfingViaDNSTunnel/runIodine.png"></p><p>另外，可以上<a href="https://code.kryo.se/iodine/check-it/">https://code.kryo.se/iodine/check-it/</a>这个网站输入监听解析域名，上面例子就是zwc.coolcc.top，验证iodine工作是否正常。如下图，返回结果提示iodine工作没问题。 </p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/surfingViaDNSTunnel/checkIodine.png"></p><h3 id="本地主机配置"><a href="#本地主机配置" class="headerlink" title="本地主机配置"></a>本地主机配置</h3><p>本地主机同样先安装好所需环境和软件，安装包都能在对应官网上找到下载，这里也不赘述详细安装过程了。注意的问题一是OpenVpn最好用2.3.10版本，因为一开始用2.3.13版本网络无法连通，换成2.3.10之后就好了，二是安装OpenVpn时只需要勾选安装T<code>AP Virtual Ethernet Adapter</code>一项即可，因为只需要用到OpenVpn生成的这个TAP网络适配器来沟通连接服务器的网卡。</p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/surfingViaDNSTunnel/installOpenVPN.png"></p><p>安装完后启动iodine服务。以管理管身份运行cmd，在cmd中进入到iodine的32位或者64位目录下，输入<code>iodine -f -P 12345678 203.195.135.206 zwc.coolcc.top</code>指令启动iodine，与云主机建立DNS隧道，注意到输入参数为云主机的公网IP，12345678为云主机端的iodine程序设置的密码。成功建立后可以窗口如下图所示。</p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/surfingViaDNSTunnel/runIodine1.png"></p><p>可以另开一个cmd测试一下此时本地主机与云主机的连通性，ping一下云主机之前设置的DNS服务器地址，效果如下图所示。</p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/surfingViaDNSTunnel/ping.png"></p><p>现在要启用ShadowSocks代理，选项按照云主机的配置文件填写就可以了，如下图编辑服务器界面。最后右击任务栏ShadowSocks小图标，正式启用ShadowSocks系统代理，并把代理模式改成全局代理模式。 </p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/surfingViaDNSTunnel/xshellConnect.png"></p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>去学校隔壁的麦当劳，连接上麦当劳的wifi，理所当然地弹出了Web的Portal认证页面</p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/surfingViaDNSTunnel/McDonloadPortal.png"></p><p>无视麦当劳的认证界面，打开浏览器别的选项卡输入网址浏览，发现网页都能打开，说明我们的实验成功了。在百度搜索中输入IP，显示的IP为云主机的公网IP地址，属于腾讯云，说明我们的代理设置也成功了。但是在这种上网情况下，QQ微信等即时通讯软件是无法使用的，因为数据不走DNS解析通道，这也能解释有时候网页打不开但是QQ能上的现象，就是因为DNS解析的问题。</p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/surfingViaDNSTunnel/queryIP.png"></p><p>现在测试一下采用这种方式的上网通信质量，打开老牌的网络测速网站SpeedTest，任选一个测速点测试本地主机与测速点的通信质量。在测速报告中可以看到下载上传速度都在1Mbps左右，网络质量不太好，打开网页和加载网络图片也感到明显卡顿，延迟高 </p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/surfingViaDNSTunnel/testMbps.png"></p><p>网络质量不好的原因在于三方面，一是我们购置的云主机为最低配，网络带宽配置仅有1Mbps，从这么低的带宽自然无法得到良好的上网体验；二是网络的多重处理转发性，经历了本地主机软件的伪造DNS数据包处理，内部DNS服务器的转发，远程主机的接收还原这么多步骤后，才开始通过远程主机与互联网的连接真正处理网络请求数据，接收到响应数据之后还要重新逆执行前面的步骤，这样复杂的转发机制无疑加大的延迟，降低网络质量；三是UDP协议的不可靠性，虽然快捷但是不保证可靠，提升传输丢包的风险，再次影响了上网体验。 </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/bonelee/p/8059464.html">iodine免费上网 </a></p><p><a href="https://qiuri.org/806.html">透过DNS Tunnel绕过校园网认证系统实现免费上网 </a></p><p><a href="https://blog.csdn.net/qq_35422558/article/details/78018089">UDP绕过校园网，纯手工搭建 </a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>微信红包抓包和原理分析</title>
    <link href="/2018/06/12/%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85%E5%88%86%E6%9E%90/"/>
    <url>/2018/06/12/%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="抓包方式"><a href="#抓包方式" class="headerlink" title="抓包方式"></a>抓包方式</h2><p>抓取微信红包数据包的工具是 <strong>Wireshark</strong>。Wireshark 的功能无需赘述了，最强大<br>的网络封包协议分析软件，没有之一。</p><p>另外还有手机型号系统和微信版本的问题，尝试过安卓系统手机和高版本的微信，只抓到两个微信红包数据包，难以进行分析，最后确定是在苹果系统和微信 6.5版本环境下才能抓到理想的数据包。</p><p>抓取微信红包数据包的方式就是笔记本电脑通过 WIFI 连接路由器上网，然后利用笔记本电脑网<br>卡的双频收发功能，连接 WIFI 的同时开启热点，手机WIFI 连接电脑开启的热点上网，最后在<br>Wireshark 中监听开启笔记本热点的网络连接即可。注意到 Wireshark 的抓包能力过强，抓到网络<br>协议的多层数据包，信息量巨大繁杂，因此要在过滤器工具栏中添加 http 协议的过滤规则，方便抓包。</p><h2 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h2><p>关于微信红包，一般是发红包，收红包和查看红包这三个流程。</p><p>发红包</p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/wechatRedPacketAnalysis/sendRedPacket.png"></p><p>收红包</p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/wechatRedPacketAnalysis/receiveRedPacket.png"></p><p>查看红包</p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/wechatRedPacketAnalysis/queryRedPacket.png"></p><p>每个数据包的Info一栏中的英文字段能直观地反应出这个数据包的作用，而高版本的微信再次巩固了安全性，对Info一栏进行了加密，变成复杂的英文数字组合。也可以看出<strong>红包的发起请求方法为POST</strong>，参数不会被保存，比起GET请求方法更加安全。在这些数据包中任意选中一个查看详情，发现主要交互域名为<strong>short.weixin.qq.com</strong>，实验时服务器的IP地址为同一个，为<strong>182.254.92.141</strong>。</p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/wechatRedPacketAnalysis/mainDomain.png"></p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/wechatRedPacketAnalysis/sameIPAddress.png"></p><h2 id="红包延迟"><a href="#红包延迟" class="headerlink" title="红包延迟"></a>红包延迟</h2><p>抢红包延迟可以分为<strong>网络传输延迟</strong>和<strong>用户终端延迟</strong>两类。</p><p>从数据包角度来看，网络传输延迟主要发生在收到红包和打开红包这两个会话的延迟，如下图时间所示，客户端点击收到的红包消息时请求服务器，直至收到服务器返回红包状态的响应，来回延迟大约为0.11s。客户端点击拆开红包时请求服务器，直至收到服务器返回红包已打开和金额详情的响应，来回延迟则大约为0.53s。可见拆开红包时涉及了红包金额分配算法运行和支付管理入账等安全操作，需要更多的时间，<strong>服务器回复客户端显然要比单纯回复红包是否被抢光的前一个请求慢得多。</strong> </p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/wechatRedPacketAnalysis/networkLatency.png"></p><p>用户终端延迟则包括了<strong>用户操作延迟</strong>和<strong>用户终端UI延迟</strong>。用户操作延迟无可厚非就是看人的反应和点击速度快慢了，因人而异。用户终端UI延迟集中在屏幕的物理响应和UI绘制延迟，据网上资料显示，苹果手机凭借着优异的系统性能和屏幕响应机制，抢红包比安卓手机更占优势。 </p><p><a href="https://weibo.com/p/1001603814272596583142">参考</a></p><p>至于供应商流量环境和WIFI环境下的抢红包速度对比，一般而言，<strong>WIFI抢红包速度胜于流量</strong>。距离方面，无线传输距离越长，则耗费时间越长。WIFI环境下用户终端到路由器距离比流量环境下到基站距离短，减少了延迟，信号到达路由器或者基站后就能以有线光缆光速传输。设计标准方面，流量环境下的最佳技术LTE的目标时延为100ms，而WIFI在轻载之下可以达到10ms左右，速度相差了五倍。另外一个考虑因素是网络运营商建设，WIFI连接的有线网络运营商电信的骨干网建设优于流量运营商移动联通。腾讯的微信服务器和相关的红包服务器更有可能搭建在中国电信骨干网上。</p><h2 id="红包规律"><a href="#红包规律" class="headerlink" title="红包规律"></a>红包规律</h2><p>研究<strong>红包领取顺序与领取到的红包金额之间的关系</strong>。发红包设计方案如下：红包总额为20元，红包总数为20个，一共进行十轮红包发放，然后统计数据并分析，表格数据如下，黄色高亮为该轮最佳手气。</p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/wechatRedPacketAnalysis/tableData.png"></p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/wechatRedPacketAnalysis/xychart.png"></p><p>从散点图看出，绝大多数红包的金额大小<strong>分布在所有样本均值1附近</strong>。横坐标越大，纵坐标增大的概率越高，也就是说，最佳手气大多分布在领取顺序靠后的编号中，<strong>领取红包顺序越后，越容易领到最佳手气红包</strong>。因此，对于喜欢拼最佳手气的冒险主义者来说，不必见到红包就马上下手，静候片刻再拆开，或许能愿望成真，不过需要承担过于迟拆开导致红包被领光的风险。 </p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/wechatRedPacketAnalysis/meanLineChart.png"></p><p>从均值折线图看出，均值随领取顺序变化波动较为剧烈，但总体还是<strong>围绕1上下波动变化的</strong>，也有可能是样本数据过少，个体偶然因素影响大，导致样本不够典型。因此，想利用上面“越后抢红包越容易拿最佳手气”这条规律的也不用沾沾自喜，白忙活一场抢红包大战下来，有可能抢到的跟别人的随缘抢也差不多，<strong>大家抢到的红包面额在概率上是大致均匀的</strong>。 </p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/wechatRedPacketAnalysis/stdLineChart.png"></p><p>从标准差折线图看出，横坐标增大，纵坐标也增大，就是说<strong>标准差随着领取时间的增大而增大</strong>。标准差能够描述数据的离散程度，说明数据的稳定性，标准差越大，数据则波动得越剧烈。这也印证了前面的说法，往后容易领到大金额红包，为了把均值稳定在1附近，也容易领到小金额红包，因而这种极端值过多的情况使得标准差和方差增大。</p><p>总结，研究得到的微信红包规律性如下：<strong>微信红包是公平的，多次抢红包，领取到的金额是差不多的。每次领取顺序越前，领到的红包金额越是稳定在均值，领取顺序越后，领到的红包越是可能手气最佳或者手气最差。</strong></p><h2 id="红包算法"><a href="#红包算法" class="headerlink" title="红包算法"></a>红包算法</h2><p>根据资料，可认为微信红包满足的是<strong>截尾正态分布</strong>，算法即在截尾正态分布中取随机数，并用其求和数除以总价值，获得修正因子，再用修正因子乘上所有的随机数，得到红包价值。这种分布意味着：减少抽取红包大小分布的方差，让更多的人抽取的红包在均值附近，同时仍给一小部分人抽取大红包的机会，总体来说增加了红包抽取人的积极性和游戏的公平性。</p><p>并且为了防止最后领红包的人领时红包余额为0，红包机制可能为：当发红包者&lt;准备红包&gt;的时候，程序自动依照截尾分布产生了相应大小，相应个数的红包，然后随机发给抽取红包的人。同样，这样的一个随机过程有助于增加游戏的公平性，也减少了红包抽取人投机操作（亦即譬如故意等钱包半空的时候再抽取）的动机。 也即是说，不论先拿后拿，期望都是相同的。</p><p><a href="http://coderroc.com/article/%E6%95%B0%E5%AD%A6%E5%92%8C%E7%AE%97%E6%B3%95/%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95%E5%88%9D%E6%8E%A2.html">参考</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Github静态页面自定义域名开启Https</title>
    <link href="/2018/06/02/Github%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%BC%80%E5%90%AFHttps/"/>
    <url>/2018/06/02/Github%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%BC%80%E5%90%AFHttps/</url>
    
    <content type="html"><![CDATA[<p>最近Github静态页面支持了自定义域名开启Https，本站顺势也可以换上小绿锁。</p><p> <a href="https://help.github.com/articles/setting-up-an-apex-domain/">官方支持页面</a></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>Https加密，防劫持</li><li>基于Https的CDN优化，加快网站加载时间</li><li>提供了额外防护DDoS攻击的服务</li><li>强迫症福利，地址栏旁边的 ”不安全“变成小绿锁</li></ul><h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>如官方文档所言更新DNS解析地址，我这里的域名服务是阿里云提供的，原本是</p><table><thead><tr><th>记录类型</th><th>主机记录</th><th>记录值</th></tr></thead><tbody><tr><td>A</td><td>@</td><td>151.101.229.147</td></tr><tr><td>CNAME</td><td>www</td><td>zwczwc.github.io</td></tr></tbody></table><p>对A类型记录修改增加为官方提供的四个IP地址，在官方文档里有。最终结果为</p><table><thead><tr><th>记录类型</th><th>主机记录</th><th>记录值</th></tr></thead><tbody><tr><td>A</td><td>@</td><td>185.199.111.153</td></tr><tr><td>A</td><td>@</td><td>185.199.110.153</td></tr><tr><td>A</td><td>@</td><td>185.199.109.153</td></tr><tr><td>A</td><td>@</td><td>185.199.108.153</td></tr><tr><td>CNAME</td><td>www</td><td>zwczwc.github.io</td></tr></tbody></table><p>确认保存解析设置即可，很快就会生效。</p><h3 id="Github设置"><a href="#Github设置" class="headerlink" title="Github设置"></a>Github设置</h3><p>打开Github静态页面所在的Repository，点入最右边的<code>Settings</code>，定位到<code>Pages</code>一栏，勾上<code>Enforce HTTPS</code>。</p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/githubHttps/enforceHttps.png"></p><p>发现无法勾上，旁边提示 <code>Not yet available for your site because the certificate has not finished being issued  </code>，这时可以把上面填在<code>Custom domain</code>里的自定义域名清空，保存，然后重新填上自定义域名，再保存。</p><p>然后发现<code>Enforce HTTPS</code>可以勾选了，果断勾选上，然后证书很快就会签发成功，现在可以打开自定义域名看看效果了。</p><p><img src="https://raw.githubusercontent.com/zwczwc/res/master/2018/githubHttps/success.png"></p><p>大功告成！</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
